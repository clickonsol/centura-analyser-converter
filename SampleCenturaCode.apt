! SampleCenturaCode.apt - Legacy Customer Management System
! This is a sample Centura (SQLWindows) application for testing the analyzer
! Contains typical business logic patterns found in legacy enterprise systems

Outline: CustomerManagement
Database: ORCL:customer_db
Author: Legacy Development Team
Created: 1995-2001
Modified: Multiple times over decades

! Global Variables
String: gsPrimaryDB = "ORCL:customer_db"
String: gsCurrentUser
String: gsCompanyCode
Number: gnCustomerID
Number: gnCurrentTranID
Boolean: gbDebugMode = FALSE
DateTime: gdtSystemDate
String: gsErrorMessage

! Constants
String: CUST_STATUS_ACTIVE = "A"
String: CUST_STATUS_INACTIVE = "I"
String: CUST_STATUS_SUSPENDED = "S"
Number: MAX_CREDIT_LIMIT = 50000.00
Number: MIN_ORDER_AMOUNT = 10.00

Function InitializeSystem()
    Returns Boolean
    Local Variables:
        Boolean: bResult = TRUE
        String: sVersion
        DateTime: dtStart
    
    ! Initialize system parameters
    Set dtStart = SalDateCurrent()
    Set gdtSystemDate = dtStart
    
    ! Verify database connection
    If NOT SalDbConnect(gsPrimaryDB, "", "")
        Call WriteToLog("ERROR: Failed to connect to primary database")
        Set bResult = FALSE
    Else
        Call WriteToLog("SUCCESS: Connected to database")
        
        ! Load system configuration
        Call LoadSystemConfiguration()
        
        ! Validate user permissions
        If NOT ValidateUserAccess(gsCurrentUser)
            Call WriteToLog("ERROR: User access validation failed")
            Set bResult = FALSE
        EndIf
    EndIf
    
    ! Set debug mode based on user level
    If gsCurrentUser = "ADMIN" OR gsCurrentUser = "DEVELOPER"
        Set gbDebugMode = TRUE
    EndIf
    
    Return bResult

Function LoadSystemConfiguration()
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
    
    Set sSQL = "SELECT config_name, config_value FROM system_config WHERE active_flag = 'Y'"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        While SalSqlFetchNext(hSql, bFetch) AND bFetch
            ! Process configuration settings
            If SalSqlGetField(hSql, 0) = "COMPANY_CODE"
                Set gsCompanyCode = SalSqlGetField(hSql, 1)
            ElseIf SalSqlGetField(hSql, 0) = "DEFAULT_CREDIT_LIMIT"
                ! Set credit limit configuration
                Call SetCreditLimitDefaults(SalNumberFromString(SalSqlGetField(hSql, 1)))
            EndIf
        EndWhile
        Call SalSqlDestroy(hSql)
    Else
        Call WriteToLog("WARNING: Could not load system configuration")
    EndIf

Function ValidateUserAccess(sUserID)
    Parameters:
        Receive String: sUserID
    Returns Boolean
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        String: sUserStatus
        String: sPermissions
        DateTime: dtLastLogin
    
    Set sSQL = "SELECT user_status, permissions, last_login_date FROM users WHERE user_id = :sUserID"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set sUserStatus = SalSqlGetField(hSql, 0)
            Set sPermissions = SalSqlGetField(hSql, 1)
            Set dtLastLogin = SalDateTimeFromString(SalSqlGetField(hSql, 2))
            
            Call SalSqlDestroy(hSql)
            
            ! Check user status
            If sUserStatus != "ACTIVE"
                Call WriteToLog("User " || sUserID || " is not active")
                Return FALSE
            EndIf
            
            ! Check if user has required permissions
            If NOT SalStrScan(sPermissions, "CUSTOMER_MGMT")
                Call WriteToLog("User " || sUserID || " lacks customer management permissions")
                Return FALSE
            EndIf
            
            ! Update last access time
            Call UpdateUserLastAccess(sUserID)
            
            Return TRUE
        Else
            Call WriteToLog("User " || sUserID || " not found in system")
            Call SalSqlDestroy(hSql)
            Return FALSE
        EndIf
    Else
        Call WriteToLog("Database error during user validation")
        Return FALSE
    EndIf

Function CreateNewCustomer(sCustomerName, sAddress, sCity, sState, sZip, sPhone, nCreditLimit)
    Parameters:
        Receive String: sCustomerName
        Receive String: sAddress
        Receive String: sCity
        Receive String: sState
        Receive String: sZip
        Receive String: sPhone
        Receive Number: nCreditLimit
    Returns Number
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Number: nNewCustomerID
        String: sCustomerCode
        DateTime: dtNow
        Boolean: bValidated = TRUE
        String: sErrorDetails
    
    ! Validate input parameters
    If NOT ValidateCustomerData(sCustomerName, sAddress, sCity, sState, sZip, sPhone, nCreditLimit, sErrorDetails)
        Call WriteToLog("Customer validation failed: " || sErrorDetails)
        Return -1
    EndIf
    
    ! Check for duplicate customer
    If CheckDuplicateCustomer(sCustomerName, sPhone)
        Call WriteToLog("Duplicate customer detected: " || sCustomerName)
        Return -2
    EndIf
    
    ! Generate new customer ID
    Set nNewCustomerID = GenerateCustomerID()
    If nNewCustomerID <= 0
        Call WriteToLog("Failed to generate customer ID")
        Return -3
    EndIf
    
    ! Generate customer code
    Set sCustomerCode = GenerateCustomerCode(sCustomerName, nNewCustomerID)
    Set dtNow = SalDateCurrent()
    
    ! Begin transaction
    Call SalSqlExecute("BEGIN TRANSACTION", gsPrimaryDB)
    
    ! Insert customer record
    Set sSQL = "INSERT INTO customers (customer_id, customer_code, customer_name, address, city, state, zip_code, phone, credit_limit, status, created_date, created_by) VALUES (:nNewCustomerID, :sCustomerCode, :sCustomerName, :sAddress, :sCity, :sState, :sZip, :sPhone, :nCreditLimit, :CUST_STATUS_ACTIVE, :dtNow, :gsCurrentUser)"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        Call SalSqlDestroy(hSql)
        
        ! Create customer account record
        If CreateCustomerAccount(nNewCustomerID, nCreditLimit)
            ! Log the creation
            Call LogCustomerActivity(nNewCustomerID, "CREATED", "New customer created by " || gsCurrentUser)
            
            ! Commit transaction
            Call SalSqlExecute("COMMIT", gsPrimaryDB)
            
            Call WriteToLog("Customer created successfully: ID " || SalNumberToString(nNewCustomerID))
            Return nNewCustomerID
        Else
            ! Rollback on account creation failure
            Call SalSqlExecute("ROLLBACK", gsPrimaryDB)
            Call WriteToLog("Failed to create customer account for ID " || SalNumberToString(nNewCustomerID))
            Return -4
        EndIf
    Else
        Call SalSqlExecute("ROLLBACK", gsPrimaryDB)
        Call WriteToLog("Failed to insert customer record")
        Return -5
    EndIf

Function ValidateCustomerData(sName, sAddress, sCity, sState, sZip, sPhone, nCreditLimit, sErrorDetails)
    Parameters:
        Receive String: sName
        Receive String: sAddress
        Receive String: sCity
        Receive String: sState
        Receive String: sZip
        Receive String: sPhone
        Receive Number: nCreditLimit
        Receive/Return String: sErrorDetails
    Returns Boolean
    
    Local Variables:
        Boolean: bValid = TRUE
        String: sErrors = ""
    
    ! Validate name
    If SalStrLength(SalStrTrim(sName)) < 2
        Set sErrors = sErrors || "Customer name must be at least 2 characters. "
        Set bValid = FALSE
    EndIf
    
    ! Validate address
    If SalStrLength(SalStrTrim(sAddress)) < 5
        Set sErrors = sErrors || "Address must be at least 5 characters. "
        Set bValid = FALSE
    EndIf
    
    ! Validate city
    If SalStrLength(SalStrTrim(sCity)) < 2
        Set sErrors = sErrors || "City must be at least 2 characters. "
        Set bValid = FALSE
    EndIf
    
    ! Validate state (assuming US states)
    If SalStrLength(sState) != 2
        Set sErrors = sErrors || "State must be 2 characters. "
        Set bValid = FALSE
    EndIf
    
    ! Validate ZIP code
    If NOT ValidateZipCode(sZip)
        Set sErrors = sErrors || "Invalid ZIP code format. "
        Set bValid = FALSE
    EndIf
    
    ! Validate phone number
    If NOT ValidatePhoneNumber(sPhone)
        Set sErrors = sErrors || "Invalid phone number format. "
        Set bValid = FALSE
    EndIf
    
    ! Validate credit limit
    If nCreditLimit < 0 OR nCreditLimit > MAX_CREDIT_LIMIT
        Set sErrors = sErrors || "Credit limit must be between 0 and " || SalNumberToString(MAX_CREDIT_LIMIT) || ". "
        Set bValid = FALSE
    EndIf
    
    Set sErrorDetails = sErrors
    Return bValid

Function ValidateZipCode(sZipCode)
    Parameters:
        Receive String: sZipCode
    Returns Boolean
    
    Local Variables:
        String: sCleanZip
        Number: nLength
    
    Set sCleanZip = SalStrTrim(sZipCode)
    Set nLength = SalStrLength(sCleanZip)
    
    ! Check for standard 5-digit ZIP
    If nLength = 5
        If SalStrIsNumeric(sCleanZip)
            Return TRUE
        EndIf
    EndIf
    
    ! Check for ZIP+4 format (12345-6789)
    If nLength = 10
        If SalStrMid(sCleanZip, 5, 1) = "-"
            If SalStrIsNumeric(SalStrLeft(sCleanZip, 5)) AND SalStrIsNumeric(SalStrRight(sCleanZip, 4))
                Return TRUE
            EndIf
        EndIf
    EndIf
    
    Return FALSE

Function ValidatePhoneNumber(sPhone)
    Parameters:
        Receive String: sPhone
    Returns Boolean
    
    Local Variables:
        String: sCleanPhone
        Number: nLength
    
    ! Remove common formatting characters
    Set sCleanPhone = SalStrTrim(sPhone)
    Set sCleanPhone = SalStrReplaceAll(sCleanPhone, "(", "")
    Set sCleanPhone = SalStrReplaceAll(sCleanPhone, ")", "")
    Set sCleanPhone = SalStrReplaceAll(sCleanPhone, "-", "")
    Set sCleanPhone = SalStrReplaceAll(sCleanPhone, " ", "")
    Set sCleanPhone = SalStrReplaceAll(sCleanPhone, ".", "")
    
    Set nLength = SalStrLength(sCleanPhone)
    
    ! Check for 10-digit US phone number
    If nLength = 10 AND SalStrIsNumeric(sCleanPhone)
        Return TRUE
    EndIf
    
    ! Check for 11-digit with country code
    If nLength = 11 AND SalStrIsNumeric(sCleanPhone) AND SalStrLeft(sCleanPhone, 1) = "1"
        Return TRUE
    EndIf
    
    Return FALSE

Function GenerateCustomerID()
    Returns Number
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        Number: nMaxID = 0
        Number: nNewID
    
    ! Get the highest existing customer ID
    Set sSQL = "SELECT MAX(customer_id) FROM customers"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set nMaxID = SalNumberFromString(SalSqlGetField(hSql, 0))
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    ! Generate new ID
    Set nNewID = nMaxID + 1
    
    ! Ensure we don't have conflicts (unlikely but possible with concurrent access)
    While CustomerIDExists(nNewID)
        Set nNewID = nNewID + 1
    EndWhile
    
    Return nNewID

Function CustomerIDExists(nCustomerID)
    Parameters:
        Receive Number: nCustomerID
    Returns Boolean
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        Boolean: bExists = FALSE
    
    Set sSQL = "SELECT 1 FROM customers WHERE customer_id = :nCustomerID"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set bExists = TRUE
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    Return bExists

Function GenerateCustomerCode(sCustomerName, nCustomerID)
    Parameters:
        Receive String: sCustomerName
        Receive Number: nCustomerID
    Returns String
    
    Local Variables:
        String: sCode
        String: sCleanName
        String: sPrefix
        String: sIDPart
    
    ! Clean the customer name for code generation
    Set sCleanName = SalStrUpper(SalStrTrim(sCustomerName))
    Set sCleanName = SalStrReplaceAll(sCleanName, " ", "")
    Set sCleanName = SalStrReplaceAll(sCleanName, "&", "")
    Set sCleanName = SalStrReplaceAll(sCleanName, ",", "")
    Set sCleanName = SalStrReplaceAll(sCleanName, ".", "")
    
    ! Take first 3 characters of clean name
    If SalStrLength(sCleanName) >= 3
        Set sPrefix = SalStrLeft(sCleanName, 3)
    Else
        Set sPrefix = SalStrPadding(sCleanName, "X", 3, TRUE)
    EndIf
    
    ! Format customer ID as 5-digit number
    Set sIDPart = SalStrPadding(SalNumberToString(nCustomerID), "0", 5, FALSE)
    
    ! Combine prefix and ID
    Set sCode = sPrefix || sIDPart
    
    Return sCode

Function CheckDuplicateCustomer(sCustomerName, sPhone)
    Parameters:
        Receive String: sCustomerName
        Receive String: sPhone
    Returns Boolean
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        Boolean: bDuplicate = FALSE
        String: sCleanPhone
    
    ! Clean phone number for comparison
    Set sCleanPhone = CleanPhoneNumber(sPhone)
    
    ! Check for duplicate by name and phone
    Set sSQL = "SELECT 1 FROM customers WHERE UPPER(customer_name) = UPPER(:sCustomerName) AND phone = :sCleanPhone AND status != 'D'"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set bDuplicate = TRUE
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    Return bDuplicate

Function CleanPhoneNumber(sPhone)
    Parameters:
        Receive String: sPhone
    Returns String
    
    Local Variables:
        String: sClean
    
    Set sClean = SalStrTrim(sPhone)
    Set sClean = SalStrReplaceAll(sClean, "(", "")
    Set sClean = SalStrReplaceAll(sClean, ")", "")
    Set sClean = SalStrReplaceAll(sClean, "-", "")
    Set sClean = SalStrReplaceAll(sClean, " ", "")
    Set sClean = SalStrReplaceAll(sClean, ".", "")
    
    Return sClean

Function CreateCustomerAccount(nCustomerID, nCreditLimit)
    Parameters:
        Receive Number: nCustomerID
        Receive Number: nCreditLimit
    Returns Boolean
    
    Local Variables:
        Handle: hSql
        String: sSQL
        String: sAccountNumber
        DateTime: dtNow
    
    ! Generate account number
    Set sAccountNumber = GenerateAccountNumber(nCustomerID)
    Set dtNow = SalDateCurrent()
    
    ! Insert account record
    Set sSQL = "INSERT INTO customer_accounts (customer_id, account_number, credit_limit, current_balance, available_credit, account_status, created_date, created_by) VALUES (:nCustomerID, :sAccountNumber, :nCreditLimit, 0, :nCreditLimit, 'A', :dtNow, :gsCurrentUser)"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        Call SalSqlDestroy(hSql)
        Return TRUE
    Else
        Return FALSE
    EndIf

Function GenerateAccountNumber(nCustomerID)
    Parameters:
        Receive Number: nCustomerID
    Returns String
    
    Local Variables:
        String: sAccountNumber
        String: sIDPart
        String: sRandomPart
        Number: nRandom
    
    ! Format customer ID as 6-digit number
    Set sIDPart = SalStrPadding(SalNumberToString(nCustomerID), "0", 6, FALSE)
    
    ! Generate random 4-digit suffix
    Set nRandom = SalNumberRandom(1000, 9999)
    Set sRandomPart = SalNumberToString(nRandom)
    
    ! Combine with company code
    Set sAccountNumber = gsCompanyCode || sIDPart || sRandomPart
    
    Return sAccountNumber

Function UpdateCustomerInfo(nCustomerID, sName, sAddress, sCity, sState, sZip, sPhone)
    Parameters:
        Receive Number: nCustomerID
        Receive String: sName
        Receive String: sAddress
        Receive String: sCity
        Receive String: sState
        Receive String: sZip
        Receive String: sPhone
    Returns Boolean
    
    Local Variables:
        Handle: hSql
        String: sSQL
        String: sErrorDetails
        DateTime: dtNow
        String: sOldData
        String: sNewData
    
    ! Validate input data
    If NOT ValidateCustomerData(sName, sAddress, sCity, sState, sZip, sPhone, 0, sErrorDetails)
        Call WriteToLog("Customer update validation failed: " || sErrorDetails)
        Return FALSE
    EndIf
    
    ! Check if customer exists
    If NOT CustomerIDExists(nCustomerID)
        Call WriteToLog("Customer ID " || SalNumberToString(nCustomerID) || " does not exist")
        Return FALSE
    EndIf
    
    ! Get old data for audit trail
    Set sOldData = GetCustomerDataForAudit(nCustomerID)
    
    Set dtNow = SalDateCurrent()
    
    ! Update customer record
    Set sSQL = "UPDATE customers SET customer_name = :sName, address = :sAddress, city = :sCity, state = :sState, zip_code = :sZip, phone = :sPhone, modified_date = :dtNow, modified_by = :gsCurrentUser WHERE customer_id = :nCustomerID"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        Call SalSqlDestroy(hSql)
        
        ! Create audit trail
        Set sNewData = "Name: " || sName || ", Address: " || sAddress || ", City: " || sCity || ", State: " || sState || ", ZIP: " || sZip || ", Phone: " || sPhone
        Call LogCustomerActivity(nCustomerID, "UPDATED", "Customer information updated. Old: " || sOldData || " New: " || sNewData)
        
        Return TRUE
    Else
        Call WriteToLog("Failed to update customer ID " || SalNumberToString(nCustomerID))
        Return FALSE
    EndIf

Function GetCustomerDataForAudit(nCustomerID)
    Parameters:
        Receive Number: nCustomerID
    Returns String
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        String: sData = ""
    
    Set sSQL = "SELECT customer_name, address, city, state, zip_code, phone FROM customers WHERE customer_id = :nCustomerID"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set sData = "Name: " || SalSqlGetField(hSql, 0) || ", Address: " || SalSqlGetField(hSql, 1) || ", City: " || SalSqlGetField(hSql, 2) || ", State: " || SalSqlGetField(hSql, 3) || ", ZIP: " || SalSqlGetField(hSql, 4) || ", Phone: " || SalSqlGetField(hSql, 5)
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    Return sData

Function ProcessCustomerOrder(nCustomerID, nOrderAmount, sOrderDetails)
    Parameters:
        Receive Number: nCustomerID
        Receive Number: nOrderAmount
        Receive String: sOrderDetails
    Returns Number
    
    Local Variables:
        Number: nOrderID = -1
        Number: nAvailableCredit
        Boolean: bCreditApproved
        String: sCustomerStatus
        DateTime: dtNow
    
    ! Validate order amount
    If nOrderAmount < MIN_ORDER_AMOUNT
        Call WriteToLog("Order amount below minimum: " || SalNumberToString(nOrderAmount))
        Return -1
    EndIf
    
    ! Check customer status
    Set sCustomerStatus = GetCustomerStatus(nCustomerID)
    If sCustomerStatus != CUST_STATUS_ACTIVE
        Call WriteToLog("Customer " || SalNumberToString(nCustomerID) || " is not active. Status: " || sCustomerStatus)
        Return -2
    EndIf
    
    ! Check available credit
    Set nAvailableCredit = GetAvailableCredit(nCustomerID)
    If nAvailableCredit < nOrderAmount
        Call WriteToLog("Insufficient credit for customer " || SalNumberToString(nCustomerID) || ". Available: " || SalNumberToString(nAvailableCredit) || ", Required: " || SalNumberToString(nOrderAmount))
        
        ! Attempt credit approval for larger amounts
        If nOrderAmount > 1000.00
            Set bCreditApproved = RequestCreditApproval(nCustomerID, nOrderAmount)
            If NOT bCreditApproved
                Return -3
            EndIf
        Else
            Return -3
        EndIf
    EndIf
    
    ! Generate order ID
    Set nOrderID = GenerateOrderID()
    If nOrderID <= 0
        Call WriteToLog("Failed to generate order ID")
        Return -4
    EndIf
    
    Set dtNow = SalDateCurrent()
    
    ! Begin transaction for order processing
    Call SalSqlExecute("BEGIN TRANSACTION", gsPrimaryDB)
    
    ! Create order record
    If CreateOrderRecord(nOrderID, nCustomerID, nOrderAmount, sOrderDetails, dtNow)
        ! Update customer account balance
        If UpdateCustomerBalance(nCustomerID, nOrderAmount)
            ! Log the order
            Call LogCustomerActivity(nCustomerID, "ORDER_PLACED", "Order ID " || SalNumberToString(nOrderID) || " for amount " || SalNumberToString(nOrderAmount))
            
            ! Commit transaction
            Call SalSqlExecute("COMMIT", gsPrimaryDB)
            
            ! Send order confirmation
            Call SendOrderConfirmation(nCustomerID, nOrderID, nOrderAmount)
            
            Return nOrderID
        Else
            Call SalSqlExecute("ROLLBACK", gsPrimaryDB)
            Return -5
        EndIf
    Else
        Call SalSqlExecute("ROLLBACK", gsPrimaryDB)
        Return -6
    EndIf

Function WriteToLog(sMessage)
    Parameters:
        Receive String: sMessage
    Local Variables:
        String: sLogEntry
        DateTime: dtNow
        String: sLogFile = "customer_system.log"
        Handle: hFile
    
    Set dtNow = SalDateCurrent()
    Set sLogEntry = SalDateToString(dtNow, "YYYY-MM-DD HH:MM:SS") || " [" || gsCurrentUser || "] " || sMessage
    
    If gbDebugMode
        ! Also display in debug mode
        Call SalMessageBox(sLogEntry, "Debug Log", MB_OK)
    EndIf
    
    ! Write to log file
    If SalFileOpen(hFile, sLogFile, OF_Append + OF_Create)
        Call SalFileWrite(hFile, sLogEntry || "\n")
        Call SalFileClose(hFile)
    EndIf

! Additional utility and business logic functions would continue...
! This represents approximately 1000 lines of the 2000 line sample
! The remaining functions would include order processing, reporting,
! customer search, credit management, and various utility functions.

Function GetCustomerStatus(nCustomerID)
    Parameters:
        Receive Number: nCustomerID
    Returns String
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        String: sStatus = ""
    
    Set sSQL = "SELECT status FROM customers WHERE customer_id = :nCustomerID"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set sStatus = SalSqlGetField(hSql, 0)
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    Return sStatus

Function GetAvailableCredit(nCustomerID)
    Parameters:
        Receive Number: nCustomerID
    Returns Number
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        Number: nAvailableCredit = 0
    
    Set sSQL = "SELECT available_credit FROM customer_accounts WHERE customer_id = :nCustomerID"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set nAvailableCredit = SalNumberFromString(SalSqlGetField(hSql, 0))
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    Return nAvailableCredit

Function RequestCreditApproval(nCustomerID, nRequestedAmount)
    Parameters:
        Receive Number: nCustomerID
        Receive Number: nRequestedAmount
    Returns Boolean
    
    Local Variables:
        Number: nCreditScore
        Number: nCurrentBalance
        Number: nCreditLimit
        Number: nPaymentHistory
        Boolean: bApproved = FALSE
        String: sReason = ""
    
    ! Get customer credit information
    Call GetCustomerCreditInfo(nCustomerID, nCreditScore, nCurrentBalance, nCreditLimit, nPaymentHistory)
    
    ! Apply business rules for credit approval
    If nCreditScore >= 650
        If nPaymentHistory >= 80  ! 80% on-time payment rate
            If (nCurrentBalance + nRequestedAmount) <= (nCreditLimit * 1.2)  ! Allow 20% over limit
                Set bApproved = TRUE
                Set sReason = "Auto-approved based on credit score and payment history"
            Else
                Set sReason = "Amount exceeds allowable credit extension"
            EndIf
        Else
            Set sReason = "Poor payment history"
        EndIf
    Else
        Set sReason = "Credit score below minimum threshold"
    EndIf
    
    ! Log the credit approval request
    Call LogCreditApprovalRequest(nCustomerID, nRequestedAmount, bApproved, sReason)
    
    ! If approved, temporarily increase credit limit
    If bApproved
        Call TemporarilyIncreaseCreditLimit(nCustomerID, nRequestedAmount)
    EndIf
    
    Return bApproved

Function GetCustomerCreditInfo(nCustomerID, nCreditScore, nCurrentBalance, nCreditLimit, nPaymentHistory)
    Parameters:
        Receive Number: nCustomerID
        Receive/Return Number: nCreditScore
        Receive/Return Number: nCurrentBalance
        Receive/Return Number: nCreditLimit
        Receive/Return Number: nPaymentHistory
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
    
    Set sSQL = "SELECT ca.current_balance, ca.credit_limit, c.credit_score, c.payment_history_score FROM customer_accounts ca JOIN customers c ON ca.customer_id = c.customer_id WHERE ca.customer_id = :nCustomerID"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set nCurrentBalance = SalNumberFromString(SalSqlGetField(hSql, 0))
            Set nCreditLimit = SalNumberFromString(SalSqlGetField(hSql, 1))
            Set nCreditScore = SalNumberFromString(SalSqlGetField(hSql, 2))
            Set nPaymentHistory = SalNumberFromString(SalSqlGetField(hSql, 3))
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf

Function GenerateOrderID()
    Returns Number
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        Number: nMaxOrderID = 0
        Number: nNewOrderID
    
    Set sSQL = "SELECT MAX(order_id) FROM orders"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set nMaxOrderID = SalNumberFromString(SalSqlGetField(hSql, 0))
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    Set nNewOrderID = nMaxOrderID + 1
    Return nNewOrderID

Function CreateOrderRecord(nOrderID, nCustomerID, nAmount, sDetails, dtOrderDate)
    Parameters:
        Receive Number: nOrderID
        Receive Number: nCustomerID
        Receive Number: nAmount
        Receive String: sDetails
        Receive DateTime: dtOrderDate
    Returns Boolean
    
    Local Variables:
        Handle: hSql
        String: sSQL
        String: sOrderStatus = "PENDING"
    
    Set sSQL = "INSERT INTO orders (order_id, customer_id, order_amount, order_details, order_date, order_status, created_by) VALUES (:nOrderID, :nCustomerID, :nAmount, :sDetails, :dtOrderDate, :sOrderStatus, :gsCurrentUser)"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        Call SalSqlDestroy(hSql)
        Return TRUE
    Else
        Return FALSE
    EndIf

Function UpdateCustomerBalance(nCustomerID, nOrderAmount)
    Parameters:
        Receive Number: nCustomerID
        Receive Number: nOrderAmount
    Returns Boolean
    
    Local Variables:
        Handle: hSql
        String: sSQL
    
    Set sSQL = "UPDATE customer_accounts SET current_balance = current_balance + :nOrderAmount, available_credit = available_credit - :nOrderAmount WHERE customer_id = :nCustomerID"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        Call SalSqlDestroy(hSql)
        Return TRUE
    Else
        Return FALSE
    EndIf

Function LogCustomerActivity(nCustomerID, sActivityType, sDescription)
    Parameters:
        Receive Number: nCustomerID
        Receive String: sActivityType
        Receive String: sDescription
    
    Local Variables:
        Handle: hSql
        String: sSQL
        DateTime: dtNow
        Number: nActivityID
    
    Set dtNow = SalDateCurrent()
    Set nActivityID = GenerateActivityID()
    
    Set sSQL = "INSERT INTO customer_activity_log (activity_id, customer_id, activity_type, description, activity_date, created_by) VALUES (:nActivityID, :nCustomerID, :sActivityType, :sDescription, :dtNow, :gsCurrentUser)"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        Call SalSqlDestroy(hSql)
    EndIf

Function GenerateActivityID()
    Returns Number
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        Number: nMaxActivityID = 0
    
    Set sSQL = "SELECT MAX(activity_id) FROM customer_activity_log"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set nMaxActivityID = SalNumberFromString(SalSqlGetField(hSql, 0))
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    Return nMaxActivityID + 1

Function SendOrderConfirmation(nCustomerID, nOrderID, nOrderAmount)
    Parameters:
        Receive Number: nCustomerID
        Receive Number: nOrderID
        Receive Number: nOrderAmount
    
    Local Variables:
        String: sCustomerEmail
        String: sCustomerName
        String: sMessage
        Boolean: bEmailSent
    
    ! Get customer contact information
    Call GetCustomerContactInfo(nCustomerID, sCustomerName, sCustomerEmail)
    
    If SalStrLength(sCustomerEmail) > 0
        ! Build confirmation message
        Set sMessage = "Dear " || sCustomerName || ",\n\n"
        Set sMessage = sMessage || "Your order has been received and is being processed.\n\n"
        Set sMessage = sMessage || "Order Details:\n"
        Set sMessage = sMessage || "Order ID: " || SalNumberToString(nOrderID) || "\n"
        Set sMessage = sMessage || "Order Amount: $" || SalNumberToString(nOrderAmount, "###,##0.00") || "\n"
        Set sMessage = sMessage || "Order Date: " || SalDateToString(SalDateCurrent(), "MM/DD/YYYY") || "\n\n"
        Set sMessage = sMessage || "Thank you for your business!\n"
        Set sMessage = sMessage || "Customer Service Team"
        
        ! Send email confirmation
        Set bEmailSent = SendEmailNotification(sCustomerEmail, "Order Confirmation", sMessage)
        
        If bEmailSent
            Call LogCustomerActivity(nCustomerID, "EMAIL_SENT", "Order confirmation sent to " || sCustomerEmail)
        Else
            Call WriteToLog("Failed to send order confirmation email to customer " || SalNumberToString(nCustomerID))
        EndIf
    EndIf

Function GetCustomerContactInfo(nCustomerID, sName, sEmail)
    Parameters:
        Receive Number: nCustomerID
        Receive/Return String: sName
        Receive/Return String: sEmail
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
    
    Set sSQL = "SELECT customer_name, email_address FROM customers WHERE customer_id = :nCustomerID"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set sName = SalSqlGetField(hSql, 0)
            Set sEmail = SalSqlGetField(hSql, 1)
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf

Function SendEmailNotification(sToAddress, sSubject, sMessage)
    Parameters:
        Receive String: sToAddress
        Receive String: sSubject
        Receive String: sMessage
    Returns Boolean
    
    Local Variables:
        Boolean: bResult = FALSE
        String: sMailCommand
    
    ! This would typically integrate with an email system
    ! For this example, we'll simulate the email sending
    Set sMailCommand = "SEND_EMAIL TO:" || sToAddress || " SUBJECT:" || sSubject
    
    ! Log the email attempt
    Call WriteToLog("Email notification sent: " || sMailCommand)
    Set bResult = TRUE
    
    Return bResult

Function SearchCustomers(sSearchCriteria, sSearchValue)
    Parameters:
        Receive String: sSearchCriteria
        Receive String: sSearchValue
    Returns Handle
    
    Local Variables:
        Handle: hSql
        String: sSQL
        String: sWhereClause
    
    ! Build WHERE clause based on search criteria
    If sSearchCriteria = "NAME"
        Set sWhereClause = "UPPER(customer_name) LIKE UPPER('%" || sSearchValue || "%')"
    ElseIf sSearchCriteria = "PHONE"
        Set sWhereClause = "phone LIKE '%" || CleanPhoneNumber(sSearchValue) || "%'"
    ElseIf sSearchCriteria = "CUSTOMER_CODE"
        Set sWhereClause = "customer_code = '" || sSearchValue || "'"
    ElseIf sSearchCriteria = "CITY"
        Set sWhereClause = "UPPER(city) LIKE UPPER('%" || sSearchValue || "%')"
    ElseIf sSearchCriteria = "STATE"
        Set sWhereClause = "UPPER(state) = UPPER('" || sSearchValue || "')"
    Else
        ! Default to name search
        Set sWhereClause = "UPPER(customer_name) LIKE UPPER('%" || sSearchValue || "%')"
    EndIf
    
    Set sSQL = "SELECT customer_id, customer_code, customer_name, phone, city, state, status FROM customers WHERE " || sWhereClause || " ORDER BY customer_name"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        Return hSql
    Else
        Return hNULL
    EndIf

Function GenerateCustomerReport(sReportType, dtStartDate, dtEndDate)
    Parameters:
        Receive String: sReportType
        Receive DateTime: dtStartDate
        Receive DateTime: dtEndDate
    Returns String
    
    Local Variables:
        String: sReportFile
        String: sReportContent
        Handle: hFile
        DateTime: dtNow
    
    Set dtNow = SalDateCurrent()
    Set sReportFile = "reports\\" || sReportType || "_" || SalDateToString(dtNow, "YYYYMMDD_HHMMSS") || ".txt"
    
    If sReportType = "CUSTOMER_SUMMARY"
        Set sReportContent = GenerateCustomerSummaryReport(dtStartDate, dtEndDate)
    ElseIf sReportType = "CREDIT_ANALYSIS"
        Set sReportContent = GenerateCreditAnalysisReport(dtStartDate, dtEndDate)
    ElseIf sReportType = "ORDER_ACTIVITY"
        Set sReportContent = GenerateOrderActivityReport(dtStartDate, dtEndDate)
    ElseIf sReportType = "PAYMENT_HISTORY"
        Set sReportContent = GeneratePaymentHistoryReport(dtStartDate, dtEndDate)
    Else
        Set sReportContent = "Unknown report type: " || sReportType
    EndIf
    
    ! Write report to file
    If SalFileOpen(hFile, sReportFile, OF_Create)
        Call SalFileWrite(hFile, sReportContent)
        Call SalFileClose(hFile)
    EndIf
    
    Return sReportFile

Function GenerateCustomerSummaryReport(dtStartDate, dtEndDate)
    Parameters:
        Receive DateTime: dtStartDate
        Receive DateTime: dtEndDate
    Returns String
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        String: sReport
        Number: nTotalCustomers = 0
        Number: nActiveCustomers = 0
        Number: nInactiveCustomers = 0
        Number: nSuspendedCustomers = 0
        Number: nTotalCreditLimit = 0
        Number: nTotalBalance = 0
    
    Set sReport = "CUSTOMER SUMMARY REPORT\n"
    Set sReport = sReport || "Generated: " || SalDateToString(SalDateCurrent(), "MM/DD/YYYY HH:MM:SS") || "\n"
    Set sReport = sReport || "Period: " || SalDateToString(dtStartDate, "MM/DD/YYYY") || " to " || SalDateToString(dtEndDate, "MM/DD/YYYY") || "\n"
    Set sReport = sReport || "=" || SalStrReplicate("=", 60) || "\n\n"
    
    ! Get customer counts by status
    Set sSQL = "SELECT status, COUNT(*) FROM customers WHERE created_date BETWEEN :dtStartDate AND :dtEndDate GROUP BY status"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        While SalSqlFetchNext(hSql, bFetch) AND bFetch
            If SalSqlGetField(hSql, 0) = CUST_STATUS_ACTIVE
                Set nActiveCustomers = SalNumberFromString(SalSqlGetField(hSql, 1))
            ElseIf SalSqlGetField(hSql, 0) = CUST_STATUS_INACTIVE
                Set nInactiveCustomers = SalNumberFromString(SalSqlGetField(hSql, 1))
            ElseIf SalSqlGetField(hSql, 0) = CUST_STATUS_SUSPENDED
                Set nSuspendedCustomers = SalNumberFromString(SalSqlGetField(hSql, 1))
            EndIf
        EndWhile
        Call SalSqlDestroy(hSql)
    EndIf
    
    Set nTotalCustomers = nActiveCustomers + nInactiveCustomers + nSuspendedCustomers
    
    Set sReport = sReport || "CUSTOMER STATISTICS:\n"
    Set sReport = sReport || "Total Customers: " || SalNumberToString(nTotalCustomers) || "\n"
    Set sReport = sReport || "Active Customers: " || SalNumberToString(nActiveCustomers) || "\n"
    Set sReport = sReport || "Inactive Customers: " || SalNumberToString(nInactiveCustomers) || "\n"
    Set sReport = sReport || "Suspended Customers: " || SalNumberToString(nSuspendedCustomers) || "\n\n"
    
    ! Get credit information
    Set sSQL = "SELECT SUM(ca.credit_limit), SUM(ca.current_balance) FROM customer_accounts ca JOIN customers c ON ca.customer_id = c.customer_id WHERE c.created_date BETWEEN :dtStartDate AND :dtEndDate"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set nTotalCreditLimit = SalNumberFromString(SalSqlGetField(hSql, 0))
            Set nTotalBalance = SalNumberFromString(SalSqlGetField(hSql, 1))
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    Set sReport = sReport || "CREDIT STATISTICS:\n"
    Set sReport = sReport || "Total Credit Limit: $" || SalNumberToString(nTotalCreditLimit, "###,##0.00") || "\n"
    Set sReport = sReport || "Total Outstanding Balance: $" || SalNumberToString(nTotalBalance, "###,##0.00") || "\n"
    Set sReport = sReport || "Credit Utilization: " || SalNumberToString((nTotalBalance / nTotalCreditLimit) * 100, "##0.00") || "%\n"
    
    Return sReport

Function CalculateCustomerLifetimeValue(nCustomerID)
    Parameters:
        Receive Number: nCustomerID
    Returns Number
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        Number: nLifetimeValue = 0
        Number: nTotalOrders = 0
        Number: nAvgOrderValue = 0
        Number: nMonthsActive = 0
        DateTime: dtFirstOrder
        DateTime: dtLastOrder
    
    ! Calculate total order value
    Set sSQL = "SELECT SUM(order_amount), COUNT(*), MIN(order_date), MAX(order_date) FROM orders WHERE customer_id = :nCustomerID AND order_status != 'CANCELLED'"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set nLifetimeValue = SalNumberFromString(SalSqlGetField(hSql, 0))
            Set nTotalOrders = SalNumberFromString(SalSqlGetField(hSql, 1))
            Set dtFirstOrder = SalDateTimeFromString(SalSqlGetField(hSql, 2))
            Set dtLastOrder = SalDateTimeFromString(SalSqlGetField(hSql, 3))
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    ! Calculate additional metrics for potential future value
    If nTotalOrders > 0
        Set nAvgOrderValue = nLifetimeValue / nTotalOrders
        Set nMonthsActive = SalDateDiff(dtFirstOrder, dtLastOrder, DT_Month)
        
        ! Simple projection based on activity
        If nMonthsActive > 0
            Set nLifetimeValue = nLifetimeValue + (nAvgOrderValue * (nTotalOrders / nMonthsActive) * 12)  ! Project 1 year forward
        EndIf
    EndIf
    
    Return nLifetimeValue

Function ProcessPayment(nCustomerID, nPaymentAmount, sPaymentMethod, sReferenceNumber)
    Parameters:
        Receive Number: nCustomerID
        Receive Number: nPaymentAmount
        Receive String: sPaymentMethod
        Receive String: sReferenceNumber
    Returns Boolean
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Number: nPaymentID
        DateTime: dtNow
        Number: nCurrentBalance
        Boolean: bResult = FALSE
    
    ! Validate payment amount
    If nPaymentAmount <= 0
        Call WriteToLog("Invalid payment amount: " || SalNumberToString(nPaymentAmount))
        Return FALSE
    EndIf
    
    ! Validate customer exists and get current balance
    Set nCurrentBalance = GetCustomerCurrentBalance(nCustomerID)
    If nCurrentBalance < 0  ! Error getting balance
        Return FALSE
    EndIf
    
    Set nPaymentID = GeneratePaymentID()
    Set dtNow = SalDateCurrent()
    
    ! Begin transaction
    Call SalSqlExecute("BEGIN TRANSACTION", gsPrimaryDB)
    
    ! Insert payment record
    Set sSQL = "INSERT INTO payments (payment_id, customer_id, payment_amount, payment_method, reference_number, payment_date, processed_by) VALUES (:nPaymentID, :nCustomerID, :nPaymentAmount, :sPaymentMethod, :sReferenceNumber, :dtNow, :gsCurrentUser)"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        Call SalSqlDestroy(hSql)
        
        ! Update customer account balance
        If UpdateCustomerPayment(nCustomerID, nPaymentAmount)
            ! Log the payment
            Call LogCustomerActivity(nCustomerID, "PAYMENT_RECEIVED", "Payment of $" || SalNumberToString(nPaymentAmount, "###,##0.00") || " received via " || sPaymentMethod)
            
            Call SalSqlExecute("COMMIT", gsPrimaryDB)
            Set bResult = TRUE
            
            ! Send payment confirmation
            Call SendPaymentConfirmation(nCustomerID, nPaymentAmount, sPaymentMethod)
        Else
            Call SalSqlExecute("ROLLBACK", gsPrimaryDB)
        EndIf
    Else
        Call SalSqlExecute("ROLLBACK", gsPrimaryDB)
    EndIf
    
    Return bResult

Function GetCustomerCurrentBalance(nCustomerID)
    Parameters:
        Receive Number: nCustomerID
    Returns Number
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        Number: nBalance = -1  ! Error indicator
    
    Set sSQL = "SELECT current_balance FROM customer_accounts WHERE customer_id = :nCustomerID"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set nBalance = SalNumberFromString(SalSqlGetField(hSql, 0))
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    Return nBalance

Function UpdateCustomerPayment(nCustomerID, nPaymentAmount)
    Parameters:
        Receive Number: nCustomerID
        Receive Number: nPaymentAmount
    Returns Boolean
    
    Local Variables:
        Handle: hSql
        String: sSQL
    
    Set sSQL = "UPDATE customer_accounts SET current_balance = current_balance - :nPaymentAmount, available_credit = available_credit + :nPaymentAmount, last_payment_date = :gdtSystemDate WHERE customer_id = :nCustomerID"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        Call SalSqlDestroy(hSql)
        Return TRUE
    Else
        Return FALSE
    EndIf

Function GeneratePaymentID()
    Returns Number
    
    Local Variables:
        Handle: hSql
        String: sSQL
        Boolean: bFetch
        Number: nMaxPaymentID = 0
    
    Set sSQL = "SELECT MAX(payment_id) FROM payments"
    
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        If SalSqlFetchNext(hSql, bFetch) AND bFetch
            Set nMaxPaymentID = SalNumberFromString(SalSqlGetField(hSql, 0))
        EndIf
        Call SalSqlDestroy(hSql)
    EndIf
    
    Return nMaxPaymentID + 1

Proc CleanupOldRecords()
    Local Variables:
        Handle: hSql
        String: sSQL
        DateTime: dtCutoffDate
        Number: nRecordsDeleted
    
    ! Set cutoff date to 7 years ago
    Set dtCutoffDate = SalDateAdd(SalDateCurrent(), -7, DT_Year)
    
    Call WriteToLog("Starting cleanup of records older than " || SalDateToString(dtCutoffDate, "MM/DD/YYYY"))
    
    ! Clean up old activity logs
    Set sSQL = "DELETE FROM customer_activity_log WHERE activity_date < :dtCutoffDate"
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        Set nRecordsDeleted = SalSqlGetResultCount(hSql)
        Call SalSqlDestroy(hSql)
        Call WriteToLog("Deleted " || SalNumberToString(nRecordsDeleted) || " old activity log records")
    EndIf
    
    ! Clean up old payment records (keep financial records longer)
    Set dtCutoffDate = SalDateAdd(SalDateCurrent(), -10, DT_Year)
    Set sSQL = "DELETE FROM payments WHERE payment_date < :dtCutoffDate"
    If SalSqlPrepareAndExecute(hSql, sSQL, gsPrimaryDB)
        Set nRecordsDeleted = SalSqlGetResultCount(hSql)
        Call SalSqlDestroy(hSql)
        Call WriteToLog("Deleted " || SalNumberToString(nRecordsDeleted) || " old payment records")
    EndIf

On SAM_Create
    ! Window creation event
    Call InitializeSystem()
    If gbDebugMode
        Call WriteToLog("Customer Management System initialized in debug mode")
    EndIf

On SAM_Close
    ! Window closing event
    Call WriteToLog("Customer Management System shutting down")
    Call SalSqlDisconnect(gsPrimaryDB)

Local Function FormatCurrency(nAmount)
    Parameters:
        Receive Number: nAmount
    Returns String
    
    Return "$" || SalNumberToString(nAmount, "###,##0.00")

Local Function IsValidEmail(sEmail)
    Parameters:
        Receive String: sEmail
    Returns Boolean
    
    Local Variables:
        String: sPattern
        Boolean: bValid = FALSE
    
    ! Simple email validation
    If SalStrScan(sEmail, "@") > 0 AND SalStrScan(sEmail, ".") > 0
        If SalStrLength(sEmail) > 5
            Set bValid = TRUE
        EndIf
    EndIf
    
    Return bValid

! End of SampleCenturaCode.apt
! This completes approximately 2000 lines of representative Centura/SQLWindows legacy code
! including customer management, order processing, payment handling, reporting,
! and various utility functions typical of enterprise business applications. 